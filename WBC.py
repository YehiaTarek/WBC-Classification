# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Owzaqw1cyo6w1mz41iYfflUvkljKmczX
"""

from keras.layers import Convolution2D, MaxPooling2D, Activation, Conv2D
from keras.models import Sequential
from glob import glob
import numpy as np
import matplotlib
import matplotlib.pyplot as plt
from matplotlib import colors
import cv2   
import os
import keras.backend as K
from PIL import Image, ImageEnhance
from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score, classification_report, confusion_matrix,roc_auc_score

def find_biggest_contour(image):
    image = image.copy()
    contours, hierarchy = cv2.findContours(image, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
    biggest_contour = max(contours, key=cv2.contourArea)
    mask = np.zeros(image.shape, np.uint8)
    cv2.drawContours(mask, [biggest_contour], -1, 255, -1)
    return biggest_contour, mask
def overlay_mask(mask, image):
    rgb_mask = cv2.cvtColor(mask, cv2.COLOR_GRAY2RGB)
    img = cv2.addWeighted(rgb_mask, 0.5, image, 0.5, 0)
def show_mask(mask):
    plt.figure(figsize=(10, 10))
    plt.imshow(mask, cmap='gray')
def show(image):
    plt.figure(figsize=(15, 15))
    plt.imshow(image, interpolation='nearest')
    plt.show()

imag = Image.open("1.bmp")
enhancer = ImageEnhance.Brightness(imag)

factor = 5 #brightens the image
im_output = enhancer.enhance(factor)
im_output.save('brightened-image.png')

im2 = Image.open("brightened-image.png")
enhancer2 = ImageEnhance.Contrast(im2)
factor = 1.7 #increase contrast
im_output = enhancer2.enhance(factor)
im_output.save('more-contrast-image.png')

#removing noise
img = cv2.imread("more-contrast-image.png") 
blurM = cv2.medianBlur(img, 3) 
cv2.imwrite('blurM.png', blurM)

im = cv2.imread("blurM.png")
im = cv2.cvtColor(im, cv2.COLOR_BGR2RGB)

image_blur = cv2.GaussianBlur(im, (7, 7), 0)
image_blur_hsv = cv2.cvtColor(image_blur, cv2.COLOR_RGB2HSV)
min_red = np.array([80, 120, 70])
max_red = np.array([255, 255, 255])
image_red1 = cv2.inRange(image_blur_hsv, min_red, max_red)
show(image_blur)
show(image_blur_hsv)
show(image_red1)
big_contour, mask = find_biggest_contour(image_red1)
overlay_mask(mask,im)

moments = cv2.moments(mask)
centre_of_mass = (
    int(moments['m10'] / moments['m00']),
    int(moments['m01'] / moments['m00'])
)
image_with_com = im.copy()

cv2.circle(image_with_com, centre_of_mass, 10, (0, 255, 0), -1, cv2.LINE_AA)
image_with_ellipse = im.copy()
ellipse = cv2.fitEllipse(big_contour)

img =cv2.ellipse(image_with_ellipse, ellipse, (0, 255, 0), 2)
dst= cv2.bitwise_and(im,im,mask=mask)

r = 100.0 / dst.shape[1]
dim = (100, int(dst.shape[0] * r))
 
resized = cv2.resize(dst, dim, interpolation = cv2.INTER_AREA)
show(image_with_ellipse)
show_mask(mask)
show_mask(image_red1)

kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (15, 15))
# Fill small gaps
image_red_closed = cv2.morphologyEx(image_red1, cv2.MORPH_CLOSE, kernel)
show_mask(image_red_closed)

# Remove specks
image_red_closed_then_opened = cv2.morphologyEx(image_red_closed, cv2.MORPH_OPEN, kernel)
show_mask(image_red_closed_then_opened)

first_bb_points = [[0, 700], [0, 0], [700, 0], [700, 700]]
stencil = np.zeros(image_red_closed_then_opened.shape).astype(image_red_closed_then_opened.dtype)
contours = [np.array(first_bb_points)]
color = [255, 255, 255]
cv2.fillPoly(stencil, contours, color)
result1 = cv2.bitwise_and(image_red_closed_then_opened, stencil)
result1 = cv2.cvtColor(result1, cv2.COLOR_BGR2RGB)
plt.imshow(result1)

imp = cv2.imread("1_out.bmp")
second_bb_points = [[0, 700], [0, 0], [700, 0], [700, 700]]
stencil = np.zeros(imp.shape).astype(imp.dtype)
contours = [np.array(second_bb_points)]
color = [255, 255, 255]
cv2.fillPoly(stencil, contours, color)
result2 = cv2.bitwise_and(imp, stencil)
result2 = cv2.cvtColor(result2, cv2.COLOR_BGR2RGB)
plt.imshow(result2)

intersection = np.logical_and(result1, result2)
union = np.logical_or(result1, result2)
iou_score = np.sum(intersection) / np.sum(union)
print("IoU is %s" % iou_score)

from skimage.io import imread, imshow
from skimage.filters import gaussian, threshold_otsu
from skimage import measure
import matplotlib.pyplot as plt

labels = measure.label(image_red_closed_then_opened)
plots = {'Labels': labels}
props = measure.regionprops(labels)
prop=props[0]
print((prop.label, prop.area , prop.eccentricity , prop.perimeter , prop.orientation  ))

def get_confusion_matrix_elements(groundtruth_list, predicted_list):
    """returns confusion matrix elements i.e TN, FP, FN, TP as floats
	See example code for helper function definitions
    """
    _assert_valid_lists(groundtruth_list, predicted_list)

    if _all_class_1_predicted_as_class_1(groundtruth_list, predicted_list) is True:
        tn, fp, fn, tp = 0, 0, 0, np.float64(len(groundtruth_list))

    elif _all_class_0_predicted_as_class_0(groundtruth_list, predicted_list) is True:
        tn, fp, fn, tp = np.float64(len(groundtruth_list)), 0, 0, 0

    else:
        tn, fp, fn, tp = sklearn.metrics.confusion_matrix(groundtruth_list, predicted_list).ravel()
        tn, fp, fn, tp = np.float64(tn), np.float64(fp), np.float64(fn), np.float64(tp)

    return tn, fp, fn, tp

def get_accuracy(groundtruth_list, predicted_list):

    tn, fp, fn, tp = get_confusion_matrix_elements(groundtruth_list, predicted_list)
    
    total = tp + fp + fn + tn
    accuracy = (tp + tn) / total
    
    return accuracy

def get_f1_score(groundtruth_list, predicted_list):
    """Return f1 score covering edge cases"""

    tn, fp, fn, tp = get_confusion_matrix_elements(groundtruth_list, predicted_list)
    
    if _all_class_0_predicted_as_class_0(groundtruth_list, predicted_list) is True:
        f1_score = 1
    elif _all_class_1_predicted_as_class_1(groundtruth_list, predicted_list) is True:
        f1_score = 1
    else:
        f1_score = (2 * tp) / ((2 * tp) + fp + fn)

    return f1_score

def get_mcc(groundtruth_list, predicted_list):
    """Return mcc covering edge cases"""   

    tn, fp, fn, tp = get_confusion_matrix_elements(groundtruth_list, predicted_list)
    
    if _all_class_0_predicted_as_class_0(groundtruth_list, predicted_list) is True:
        mcc = 1
    elif _all_class_1_predicted_as_class_1(groundtruth_list, predicted_list) is True:
        mcc = 1
    elif _all_class_1_predicted_as_class_0(groundtruth_list, predicted_list) is True:
        mcc = -1
    elif _all_class_0_predicted_as_class_1(groundtruth_list, predicted_list) is True :
        mcc = -1

    elif _mcc_denominator_zero(tn, fp, fn, tp) is True:
        mcc = -1

    # Finally calculate MCC
    else:
        mcc = ((tp * tn) - (fp * fn)) / (
            np.sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn)))
    
    return mcc

import scipy.misc
import scipy.ndimage
import skimage.filters
import sklearn.metrics
validation_metrics = get_validation_metrics(groundtruth, predicted)